#!/usr/bin/env bash

# apiseq.sh - HTTP Sequence Runner
# Executes a sequence of HTTP requests defined in a JSON configuration file
# Dependencies: bash, curl, jq

set -euo pipefail

# Disable MSYS path conversion on Windows (Git Bash)
# This prevents paths like /posts/1 from being converted to C:/Program Files/Git/posts/1
export MSYS_NO_PATHCONV=1
export MSYS2_ARG_CONV_EXCL="*"

# Color codes for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Array to store responses from each step
declare -a responses_json=()
# Array to store status codes from each step
declare -a responses_status=()
# Associative array to map step IDs to indices
declare -A response_ids=()
# Storage for user input (as JSON object)
USER_INPUT_JSON="{}"
# Array to store execution log entries (JSON objects)
declare -a execution_log=()
# Track if sequence completed successfully
SEQUENCE_COMPLETED=false
# Track if user interrupted execution
USER_INTERRUPTED=false
# Store config file path for exit trap
CONFIG_FILE_PATH=""
# Store start_step parameter for logging
START_STEP=0
# Track failed step for metadata logging
FAILED_STEP_NUM=""
FAILED_STEP_ID=""

# Temporary directory for storing response files
TEMP_DIR=$(mktemp -d)

# Handle user interruption (Ctrl+C)
handle_interrupt() {
    USER_INTERRUPTED=true
    echo "" >&2
    echo "Execution interrupted by user" >&2
    exit 130  # Standard exit code for SIGINT
}

trap handle_interrupt SIGINT SIGTERM

# Cleanup and log prompt on exit
cleanup_and_prompt() {
    local exit_code=$?

    # Always prompt to save log if there are entries (using /dev/tty for Git Bash compatibility)
    if [ ${#execution_log[@]} -gt 0 ]; then
        # Determine status based on flags
        local status="failure"
        if [ "$USER_INTERRUPTED" = "true" ]; then
            status="interrupted_by_user"
        elif [ "$SEQUENCE_COMPLETED" = "true" ]; then
            status="success"
        fi

        # Prompt user to save log
        echo "" >&2

        # Use /dev/tty to ensure input works in Git Bash on Windows
        if [ -e /dev/tty ]; then
            read -p "Would you like to save an execution log? (y/n): " -n 1 -r </dev/tty >&2
            echo "" >&2
        else
            read -p "Would you like to save an execution log? (y/n): " -n 1 -r >&2
            echo "" >&2
        fi

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Create logs directory if it doesn't exist
            mkdir -p logs

            # Generate default filename with timestamp
            local timestamp=$(date +"%Y%m%d_%H%M%S")
            local default_filename="execution_log_${timestamp}.json"

            if [ -e /dev/tty ]; then
                read -p "Enter log filename [$default_filename]: " filename </dev/tty >&2
            else
                read -p "Enter log filename [$default_filename]: " filename >&2
            fi
            filename=${filename:-$default_filename}

            # Strip any path components (only accept basename)
            filename=$(basename "$filename")

            # Append .json extension if user didn't provide any extension
            if [[ ! "$filename" =~ \. ]]; then
                filename="${filename}.json"
            fi

            # Always save to logs directory
            filename="logs/${filename}"

            # Build the complete log JSON
            # Use temp file to avoid "Argument list too long" errors with large logs
            # Create temp file in logs directory (not $TEMP_DIR which may be inaccessible in exit trap)
            local temp_log_file="logs/.execution_log_temp_$$.json"

            # Write steps array to temp file
            printf '%s\n' "${execution_log[@]}" | jq -s '.' > "$temp_log_file"

            if [ $? -ne 0 ] || [ ! -s "$temp_log_file" ]; then
                echo -e "${RED}✗${NC} Failed to create temporary log file" >&2
                rm -f "$temp_log_file" 2>/dev/null
                return 1
            fi

            # Build full log by reading steps from file (avoids command-line length limits)
            jq -n \
                --arg config "$CONFIG_FILE_PATH" \
                --arg status "$status" \
                --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
                --arg skip_steps "$START_STEP" \
                --arg failed_step_num "$FAILED_STEP_NUM" \
                --arg failed_step_id "$FAILED_STEP_ID" \
                --slurpfile steps "$temp_log_file" \
                '{
                    metadata: {
                        config_file: $config,
                        execution_status: $status,
                        timestamp: $timestamp,
                        skip_steps: ($skip_steps | tonumber),
                        executed_steps: ($steps[0] | length)
                    } + (
                        if $status == "failure" and $failed_step_num != "" then
                            {
                                failed_step: {
                                    step: ($failed_step_num | tonumber),
                                    id: $failed_step_id
                                }
                            }
                        else
                            {}
                        end
                    ),
                    steps: $steps[0]
                }' > "$filename"

            # Clean up temp file
            rm -f "$temp_log_file" 2>/dev/null

            if [ $? -eq 0 ]; then
                echo -e "${GREEN}✓${NC} Execution log saved to: $filename" >&2
            else
                echo -e "${RED}✗${NC} Failed to save execution log" >&2
            fi
        fi
    fi

    # Clean up temp directory (done at end so temp files are available for log creation)
    rm -rf "$TEMP_DIR"
}

trap cleanup_and_prompt EXIT

# Global defaults
DEFAULTS_JSON="{}"

# Global variables
VARIABLES_JSON="{}"

# Debug mode (disabled by default)
ENABLE_DEBUG=false

# Timing mode (disabled by default)
# When enabled, shows performance timing for each operation to help identify bottlenecks
ENABLE_TIMING=false

# Function to print usage
usage() {
    echo "Usage: $0 <config.json> [start_step]"
    echo ""
    echo "Execute a sequence of HTTP requests defined in a JSON configuration file."
    echo ""
    echo "Arguments:"
    echo "  config.json  - Path to the configuration file"
    echo "  start_step   - Optional: Step index to start from (0-based, default: 0)"
    echo ""
    echo "Requirements:"
    echo "  - curl"
    echo "  - jq"
    exit 1
}

# Function to output debug logs (only if debug is enabled)
debug_log() {
    if [ "$ENABLE_DEBUG" = "true" ]; then
        echo "$@" >&2
    fi
}

# Function to output timing logs (only if timing is enabled)
timing_log() {
    if [ "$ENABLE_TIMING" = "true" ]; then
        echo "$@" >&2
    fi
}

# Function to prompt user for input
# Takes a JSON object with key-value pairs (variable: prompt message)
# Updates USER_INPUT_JSON with the collected values
prompt_user_input() {
    local prompts_json="$1"
    local step_num="$2"

    echo ""
    echo -e "${BLUE}Step $step_num requires user input:${NC}"

    # Reset user input for this step
    USER_INPUT_JSON="{}"

    # Iterate through each prompt
    # Use grep to filter out empty lines from jq output
    local keys=$(echo "$prompts_json" | jq -r 'keys[]' | grep -v '^[[:space:]]*$')
    while IFS= read -r key <&3; do
        # Skip empty keys (safety check)
        if [ -z "$key" ]; then
            continue
        fi

        local prompt_message=$(echo "$prompts_json" | jq -r ".[\"$key\"]")
        echo -n "$prompt_message "

        # Read from stdin (fd 0) - waits indefinitely for user input
        read -r user_value

        # Strip ANSI escape codes from user input (in case user copied from colored terminal output)
        # This removes color codes, cursor movements, etc.
        user_value=$(echo "$user_value" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')
        debug_log "DEBUG: Stripped ANSI codes from input"

        # Add to USER_INPUT_JSON
        USER_INPUT_JSON=$(echo "$USER_INPUT_JSON" | jq --arg k "$key" --arg v "$user_value" '. + {($k): $v}')
        debug_log "DEBUG: User input collected - $key=$user_value"
    done 3<<< "$keys"

    echo ""
}

# Function to get human-readable description for curl exit codes
get_curl_error_description() {
    local exit_code="$1"
    case "$exit_code" in
        1) echo "Unsupported protocol" ;;
        2) echo "Failed to initialize" ;;
        3) echo "URL malformed" ;;
        5) echo "Couldn't resolve proxy" ;;
        6) echo "Couldn't resolve host" ;;
        7) echo "Failed to connect to host" ;;
        28) echo "Operation timeout" ;;
        35) echo "SSL connect error" ;;
        47) echo "Too many redirects" ;;
        51) echo "Server's SSL certificate invalid" ;;
        52) echo "Empty reply from server" ;;
        55) echo "Failed sending network data" ;;
        56) echo "Failed receiving network data" ;;
        60) echo "SSL certificate problem" ;;
        *) echo "Unknown error" ;;
    esac
}

# Function to launch browser with URL
# Takes a URL and opens it in the default browser
launch_browser() {
    local url="$1"
    local step_num="$2"

    echo -e "${BLUE}Opening browser to: $url${NC}"
    debug_log "DEBUG: Launching browser for step $step_num"

    # Detect OS and use appropriate command
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if command -v xdg-open &> /dev/null; then
            xdg-open "$url" &> /dev/null &
        else
            echo "Warning: xdg-open not found, cannot open browser" >&2
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        open "$url" &> /dev/null &
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
        # Use rundll32 for reliable URL opening on Windows (handles special characters better)
        rundll32.exe url.dll,FileProtocolHandler "$url" &
    else
        echo "Warning: Unsupported OS, cannot open browser" >&2
    fi
}

# Function to detect OS and package manager
detect_package_manager() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if command -v apt-get &> /dev/null; then
            echo "apt"
        elif command -v yum &> /dev/null; then
            echo "yum"
        elif command -v dnf &> /dev/null; then
            echo "dnf"
        else
            echo "unknown"
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &> /dev/null; then
            echo "brew"
        else
            echo "none"
        fi
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
        if command -v winget &> /dev/null; then
            echo "winget"
        elif command -v choco &> /dev/null; then
            echo "choco"
        elif command -v scoop &> /dev/null; then
            echo "scoop"
        else
            echo "none"
        fi
    else
        echo "unknown"
    fi
}

# Function to attempt installing a package
install_package() {
    local package_name="$1"
    local pkg_manager=$(detect_package_manager)

    echo ""
    echo "Attempting to install $package_name..."

    case "$pkg_manager" in
        apt)
            echo "Using apt-get (requires sudo)..."
            sudo apt-get update && sudo apt-get install -y "$package_name"
            ;;
        yum)
            echo "Using yum (requires sudo)..."
            sudo yum install -y "$package_name"
            ;;
        dnf)
            echo "Using dnf (requires sudo)..."
            sudo dnf install -y "$package_name"
            ;;
        brew)
            echo "Using Homebrew..."
            brew install "$package_name"
            ;;
        winget)
            echo "Using winget..."
            # winget uses different package names for jq
            if [ "$package_name" = "jq" ]; then
                winget install jqlang.jq --silent
            else
                winget install "$package_name" --silent
            fi
            ;;
        choco)
            echo "Using Chocolatey (requires admin)..."
            choco install "$package_name" -y
            ;;
        scoop)
            echo "Using Scoop..."
            scoop install "$package_name"
            ;;
        none)
            echo "No package manager found."
            return 1
            ;;
        unknown)
            echo "Unsupported operating system."
            return 1
            ;;
    esac

    return $?
}

# Function to provide manual installation instructions
show_install_instructions() {
    local package_name="$1"

    echo ""
    echo "Manual installation instructions for $package_name:"
    echo ""

    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "Ubuntu/Debian:  sudo apt-get update && sudo apt-get install $package_name"
        echo "RHEL/CentOS:    sudo yum install $package_name"
        echo "Fedora:         sudo dnf install $package_name"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macOS:          brew install $package_name"
        echo "                (Install Homebrew from https://brew.sh if needed)"
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
        if [ "$package_name" = "jq" ]; then
            echo "Windows:        winget install jqlang.jq"
            echo "    Or:         choco install jq"
            echo "                (Install Chocolatey from https://chocolatey.org if needed)"
            echo "    Or:         Download from https://stedolan.github.io/jq/download/"
        else
            echo "Windows:        curl is included with Git Bash"
            echo "                Download Git Bash from https://git-scm.com/ if needed"
        fi
    fi

    echo ""
}

# Function to check prerequisites
check_prerequisites() {
    local missing_packages=()

    # Check curl
    if ! command -v curl &> /dev/null; then
        missing_packages+=("curl")
    fi

    # Check jq
    if ! command -v jq &> /dev/null; then
        missing_packages+=("jq")
    fi

    # If all dependencies are present, return success
    if [ ${#missing_packages[@]} -eq 0 ]; then
        return 0
    fi

    # Display missing packages
    echo "Missing required dependencies: ${missing_packages[*]}"
    echo ""

    # Prompt user for auto-install
    read -p "Would you like to attempt automatic installation? (y/n): " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local install_failed=0

        for package in "${missing_packages[@]}"; do
            if install_package "$package"; then
                # Verify installation succeeded
                if command -v "$package" &> /dev/null; then
                    echo "✓ Successfully installed $package"
                else
                    echo "✗ Installation appeared to succeed but $package is still not in PATH"
                    install_failed=1
                fi
            else
                echo "✗ Failed to install $package"
                install_failed=1
            fi
        done

        if [ $install_failed -eq 1 ]; then
            echo ""
            echo "Some packages could not be installed automatically."
            for package in "${missing_packages[@]}"; do
                if ! command -v "$package" &> /dev/null; then
                    show_install_instructions "$package"
                fi
            done
            exit 1
        fi
    else
        # User declined auto-install, show manual instructions
        echo ""
        for package in "${missing_packages[@]}"; do
            show_install_instructions "$package"
        done
        exit 1
    fi
}

# Function to validate step IDs
# Ensures all steps have valid, unique IDs
validate_step_ids() {
    local config="$1"

    # Extract all step names and IDs in a SINGLE jq call (optimization: 1 call instead of N calls)
    local all_steps_data=$(echo "$config" | jq -r '.steps | to_entries | .[] | [(.key + 1), (.value.name // "Unknown"), (.value.id // "null")] | @tsv')

    if [ -z "$all_steps_data" ]; then
        return 0  # No steps to validate
    fi

    # Track seen IDs for duplicate detection
    declare -A seen_ids

    # Process each step line
    while IFS=$'\t' read -r step_num name id; do
        # Trim any trailing whitespace/carriage returns (Windows compatibility)
        id="${id%$'\r'}"
        id="${id%% }"
        id="${id## }"

        # Check if id is null
        if [ "$id" = "null" ] || [ -z "$id" ]; then
            echo "Error: Step $step_num ('$name') is missing required 'id' field" >&2
            echo "All steps must have an 'id' field for named references" >&2
            exit 1
        fi

        # Validate ID format: must start with letter, then alphanumeric/underscore/hyphen
        if ! [[ "$id" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
            echo "Error: Step $step_num ('$name') has invalid ID: '$id'" >&2
            echo "IDs must start with a letter and contain only letters, numbers, underscores, and hyphens" >&2
            exit 1
        fi

        # Check for duplicate IDs
        if [[ -v seen_ids["$id"] ]]; then
            local prev_step_num="${seen_ids[$id]}"
            echo "Error: Duplicate step ID '$id' found" >&2
            echo "  First occurrence: Step $prev_step_num" >&2
            echo "  Duplicate found: Step $step_num ('$name')" >&2
            echo "All step IDs must be unique" >&2
            exit 1
        fi

        # Mark ID as seen
        seen_ids["$id"]=$step_num
    done <<< "$all_steps_data"

    debug_log "DEBUG: All step IDs validated successfully"
}

# Function to merge defaults with step configuration
# Optimized: Single jq call instead of 20+ separate process spawns
merge_with_defaults() {
    local step_json="$1"

    # Do ALL merging in a single jq invocation
    jq -n \
        --argjson defaults "$DEFAULTS_JSON" \
        --argjson step "$step_json" \
        '
        $step as $s |
        $defaults as $d |

        # Start with step, then apply merges
        $s |

        # Merge baseUrl into URL
        if ($d.baseUrl and .url) then
            if (.url | startswith("/")) then
                .url = ($d.baseUrl + .url)
            else
                .url = (.url | gsub("\\{baseUrl\\}"; $d.baseUrl))
            end
        else . end |

        # Merge headers
        if (.skipDefaultHeaders == true) then
            if .headers then . else .headers = {} end
        else
            if $d.headers then
                .headers = (($d.headers // {}) * (.headers // {}))
            else . end
        end |

        # Merge validations
        if (.skipDefaultValidations == true) then
            if .validations then . else .validations = [] end
        else
            if $d.validations then
                .validations = (($d.validations // []) + (.validations // []))
            else . end
        end |

        # Merge timeout (step overrides default)
        if (.timeout | not) and $d.timeout then
            .timeout = $d.timeout
        else . end
        '
}

# Function to substitute variables in a string (OPTIMIZED)
# Supports syntax: {{ .vars.key }}, {{ .responses.stepId.field.subfield }}, and {{ .input.key }}
# Uses simple bash loops with minimal process spawning
substitute_variables() {
    local input="$1"
    local output="$input"

    debug_log "DEBUG: substitute_variables - input=$input"
    debug_log "DEBUG: substitute_variables - responses_json array size=${#responses_json[@]}"

    # Quick check: if no template patterns exist, return immediately
    if [[ ! "$output" =~ \{\{ ]]; then
        echo "$output"
        return
    fi

    # Find all {{ .vars.key }} patterns and replace with global variables
    local vars_iteration=0
    while [[ "$output" =~ \{\{[[:space:]]*\.vars\.([a-zA-Z0-9_]+)[[:space:]]*\}\} ]]; do
        vars_iteration=$((vars_iteration + 1))
        local var_key="${BASH_REMATCH[1]}"
        local full_match="${BASH_REMATCH[0]}"

        # Get the value from VARIABLES_JSON (single jq call)
        local value=$(echo "$VARIABLES_JSON" | jq -r ".[\"$var_key\"]")
        if [ "$value" = "null" ] || [ -z "$value" ]; then
            echo "Error: Could not extract global variable value for .vars.$var_key" >&2
            exit 1
        fi

        # Simple string replacement (bash built-in)
        output="${output//$full_match/$value}"

        if [ $vars_iteration -gt 10 ]; then
            echo "ERROR: substitute_variables - infinite loop detected in vars substitution" >&2
            exit 1
        fi
    done

    # Find all {{ .input.key }} patterns and replace with user input
    local input_iteration=0
    while [[ "$output" =~ \{\{[[:space:]]*\.input\.([a-zA-Z0-9_]+)[[:space:]]*\}\} ]]; do
        input_iteration=$((input_iteration + 1))
        local input_key="${BASH_REMATCH[1]}"
        local full_match="${BASH_REMATCH[0]}"

        # Get and URL-encode the value (single jq call)
        local value=$(echo "$USER_INPUT_JSON" | jq -r ".[\"$input_key\"] | @uri")
        if [ "$value" = "null" ] || [ -z "$value" ]; then
            echo "Error: Could not extract user input value for .input.$input_key" >&2
            exit 1
        fi

        # Simple string replacement
        output="${output//$full_match/$value}"

        if [ $input_iteration -gt 10 ]; then
            echo "ERROR: substitute_variables - infinite loop detected in input substitution" >&2
            exit 1
        fi
    done

    # Find all {{ .responses.stepId.field }} patterns (named references)
    local named_iteration=0
    while [[ "$output" =~ \{\{[[:space:]]*\.responses\.([a-zA-Z][a-zA-Z0-9_-]*)\.([^}]+)[[:space:]]*\}\} ]]; do
        named_iteration=$((named_iteration + 1))
        local step_id="${BASH_REMATCH[1]}"
        local jsonpath="${BASH_REMATCH[2]}"
        jsonpath="${jsonpath##*([[:space:]])}"  # Trim leading spaces (bash built-in)
        jsonpath="${jsonpath%%*([[:space:]])}"  # Trim trailing spaces (bash built-in)
        local full_match="${BASH_REMATCH[0]}"

        # Look up step ID in response_ids mapping
        if [[ -v response_ids["$step_id"] ]]; then
            local index="${response_ids[$step_id]}"

            # Get the value from the stored response (single jq call)
            if [ "$index" -lt "${#responses_json[@]}" ]; then
                local value=$(echo "${responses_json[$index]}" | jq -r ".$jsonpath")
                if [ "$value" = "null" ] || [ -z "$value" ]; then
                    echo "Error: Could not extract value from .responses.$step_id.$jsonpath" >&2
                    exit 1
                fi

                # Simple string replacement
                output="${output//$full_match/$value}"
            else
                echo "Error: Response index $index not found (only ${#responses_json[@]} responses stored)" >&2
                exit 1
            fi
        else
            echo "Error: No step with ID '$step_id' found or not yet executed" >&2
            echo "Available step IDs: ${!response_ids[@]}" >&2
            exit 1
        fi

        if [ $named_iteration -gt 10 ]; then
            echo "ERROR: substitute_variables - infinite loop detected in named reference substitution" >&2
            exit 1
        fi
    done

    echo "$output"
}

# Function to generate a UUID v4
generate_uuid() {
    # Generate UUID v4 (random)
    if command -v uuidgen &> /dev/null; then
        uuidgen | tr '[:upper:]' '[:lower:]'
    else
        # Fallback: generate pseudo-random UUID using /dev/urandom
        cat /proc/sys/kernel/random/uuid 2>/dev/null || \
        od -N 16 -x /dev/urandom | head -1 | awk '{OFS="-"; print $2$3,$4,$5,$6,$7$8$9}' | tr '[:upper:]' '[:lower:]'
    fi
}

# Function to replace dynamic placeholders ({{$guid}}, {{$timestamp}})
# This must be called BEFORE substitute_variables to ensure dynamic values are generated first
replace_dynamic_placeholders() {
    local input="$1"
    local output="$input"

    # Replace all {{$guid}} placeholders with actual UUIDs
    # Each occurrence gets a unique UUID
    # Use printf %s to avoid variable expansion issues with $
    while printf '%s' "$output" | grep -q '{{[[:space:]]*\$guid[[:space:]]*}}'; do
        local new_uuid=$(generate_uuid)
        debug_log "DEBUG: Replacing {{\$guid}} with $new_uuid"
        # Use awk to avoid sed's issues with $ escaping
        output=$(printf '%s' "$output" | awk '{gsub(/\{\{[[:space:]]*\$guid[[:space:]]*\}\}/, "'"$new_uuid"'"); print}')
    done

    # Replace all {{$timestamp}} placeholders with current Unix timestamp
    # Each occurrence gets the same timestamp (called once per function invocation)
    local timestamp=$(date +%s)
    while printf '%s' "$output" | grep -q '{{[[:space:]]*\$timestamp[[:space:]]*}}'; do
        debug_log "DEBUG: Replacing {{\$timestamp}} with $timestamp"
        output=$(printf '%s' "$output" | awk '{gsub(/\{\{[[:space:]]*\$timestamp[[:space:]]*\}\}/, "'"$timestamp"'"); print}')
    done

    echo "$output"
}

# Function to process body and substitute variables
process_body() {
    local body_json="$1"
    local content_type="${2:-application/json}"
    local body_format="${3:-auto}"

    debug_log "DEBUG: process_body - content_type=$content_type, body_format=$body_format"

    # Convert body JSON to string first
    local body_str=$(echo "$body_json" | jq -c '.')

    # Replace dynamic placeholders (GENERATED_GUID, TIMESTAMP) first
    body_str=$(replace_dynamic_placeholders "$body_str")

    # Then substitute variables in the body
    body_str=$(substitute_variables "$body_str")

    # Determine if we need form-urlencoded format
    local use_form_encoding=false
    if [ "$body_format" = "form-urlencoded" ]; then
        use_form_encoding=true
        debug_log "DEBUG: Using form-urlencoded (explicit bodyFormat)"
    elif [[ "$content_type" == *"application/x-www-form-urlencoded"* ]]; then
        use_form_encoding=true
        debug_log "DEBUG: Using form-urlencoded (auto-detected from Content-Type)"
    fi

    # Convert to form-urlencoded if needed (OPTIMIZED: single jq call)
    if [ "$use_form_encoding" = true ]; then
        debug_log "DEBUG: Converting body to form-urlencoded format"

        # Do ALL form encoding in a single jq invocation
        local encoded=$(echo "$body_str" | jq -r '
            if type != "object" then
                error("Body must be a JSON object for form-urlencoded format")
            else
                to_entries |
                map(
                    if (.value | type == "object" or type == "array") then
                        error("form-urlencoded does not support nested objects or arrays in field '\''" + .key + "'\''")
                    else
                        .key + "=" + (.value | tostring | @uri)
                    end
                ) |
                join("&")
            end
        ')

        if [ $? -ne 0 ]; then
            echo "Error: Failed to convert body to form-urlencoded format" >&2
            exit 1
        fi

        debug_log "DEBUG: Final form-urlencoded body: $encoded"
        echo "$encoded"
    else
        # Return JSON format
        echo "$body_str"
    fi
}

# Function to evaluate a condition
# Returns 0 (true) if condition passes, 1 (false) if it fails
evaluate_condition() {
    local condition_json="$1"
    local step_num="$2"

    # Extract condition parameters - support both "step" (ID-based) and "response" (index-based)
    local response_index=""

    # Check for "step" field first (named reference)
    if echo "$condition_json" | jq -e '.step' > /dev/null 2>&1; then
        local step_id=$(echo "$condition_json" | jq -r '.step')

        # Look up step ID in response_ids mapping
        if [[ -v response_ids["$step_id"] ]]; then
            response_index="${response_ids[$step_id]}"
            debug_log "DEBUG: evaluate_condition - resolved step ID '$step_id' to index $response_index"
        else
            echo "Error: Step $step_num condition references step '$step_id' which was not found or not yet executed" >&2
            echo "Available step IDs: ${!response_ids[@]}" >&2
            exit 1
        fi
    else
        # Fall back to "response" field (index-based, for backward compatibility)
        response_index=$(echo "$condition_json" | jq -r '.response // empty')

        if [ -z "$response_index" ]; then
            echo "Error: Step $step_num condition must have either 'step' (ID) or 'response' (index) field" >&2
            exit 1
        fi
    fi

    # Validate response index
    if [ "$response_index" -ge "${#responses_json[@]}" ]; then
        echo "Error: Step $step_num condition references response[$response_index] but only ${#responses_json[@]} responses available" >&2
        exit 1
    fi

    # Check for statusCode condition
    if echo "$condition_json" | jq -e '.statusCode' > /dev/null 2>&1; then
        local expected_status=$(echo "$condition_json" | jq -r '.statusCode')
        local actual_status="${responses_status[$response_index]}"

        if [ "$actual_status" = "$expected_status" ]; then
            return 0  # Condition passes
        else
            return 1  # Condition fails
        fi
    fi

    # Check for field-based conditions
    if echo "$condition_json" | jq -e '.field' > /dev/null 2>&1; then
        local field=$(echo "$condition_json" | jq -r '.field')
        local response_body="${responses_json[$response_index]}"

        # Check for 'exists' condition
        if echo "$condition_json" | jq -e '.exists' > /dev/null 2>&1; then
            local should_exist=$(echo "$condition_json" | jq -r '.exists')
            local value=$(echo "$response_body" | jq -r "$field" 2>/dev/null || echo "null")

            if [ "$should_exist" = "true" ]; then
                if [ "$value" != "null" ] && [ -n "$value" ]; then
                    return 0  # Field exists
                else
                    return 1  # Field doesn't exist
                fi
            else
                if [ "$value" = "null" ] || [ -z "$value" ]; then
                    return 0  # Field doesn't exist (as expected)
                else
                    return 1  # Field exists (but shouldn't)
                fi
            fi
        fi

        # Check for 'equals' condition
        if echo "$condition_json" | jq -e '.equals' > /dev/null 2>&1; then
            local expected_value=$(echo "$condition_json" | jq -r '.equals')
            # Substitute variables in expected value
            expected_value=$(substitute_variables "$expected_value")
            local actual_value=$(echo "$response_body" | jq -r "$field" 2>/dev/null || echo "null")

            if [ "$actual_value" = "$expected_value" ]; then
                return 0  # Values match
            else
                return 1  # Values don't match
            fi
        fi

        # Check for 'notEquals' condition
        if echo "$condition_json" | jq -e '.notEquals' > /dev/null 2>&1; then
            local unwanted_value=$(echo "$condition_json" | jq -r '.notEquals')
            # Substitute variables in unwanted value
            unwanted_value=$(substitute_variables "$unwanted_value")
            local actual_value=$(echo "$response_body" | jq -r "$field" 2>/dev/null || echo "null")

            if [ "$actual_value" != "$unwanted_value" ]; then
                return 0  # Values don't match (as expected)
            else
                return 1  # Values match (but shouldn't)
            fi
        fi
    fi

    # If no recognizable condition found
    echo "Error: Step $step_num has invalid condition format" >&2
    exit 1
}

# Function to execute a single HTTP request step
execute_step() {
    local step_index="$1"
    local step_json="$2"
    local step_num=$((step_index + 1))

    local t_step_start=$(date +%s%3N)
    debug_log "DEBUG: execute_step - start, step_num=$step_num"

    # Check if step requires user input
    if echo "$step_json" | jq -e '.prompts' > /dev/null 2>&1; then
        local prompts=$(echo "$step_json" | jq '.prompts')
        prompt_user_input "$prompts" "$step_num"
    fi

    # Merge step with defaults
    local t_before_merge=$(date +%s%3N)
    debug_log "DEBUG: execute_step - calling merge_with_defaults"
    step_json=$(merge_with_defaults "$step_json")
    local t_after_merge=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: merge_with_defaults took $((t_after_merge - t_before_merge))ms" >&2
    debug_log "DEBUG: execute_step - merge completed"

    # Extract step details (single jq call for performance)
    local t_before_extract=$(date +%s%3N)
    debug_log "DEBUG: execute_step - extracting step details"
    local step_details=$(echo "$step_json" | jq -r '[(.id // ""), .name, .method, .url] | @tsv')
    local step_id=$(echo "$step_details" | cut -f1)
    local name=$(echo "$step_details" | cut -f2)
    local method=$(echo "$step_details" | cut -f3)
    local url=$(echo "$step_details" | cut -f4)
    local t_after_extract=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: extract step details took $((t_after_extract - t_before_extract))ms" >&2
    debug_log "DEBUG: execute_step - extracted url=$url"

    # Replace dynamic placeholders in URL first ({{$guid}}, {{$timestamp}})
    local t_before_dynamic=$(date +%s%3N)
    debug_log "DEBUG: execute_step - replacing dynamic placeholders in url"
    url=$(replace_dynamic_placeholders "$url")
    local t_after_dynamic=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: replace_dynamic_placeholders took $((t_after_dynamic - t_before_dynamic))ms" >&2
    debug_log "DEBUG: execute_step - after dynamic replacement url=$url"

    # Then substitute variables in URL
    local t_before_subst=$(date +%s%3N)
    debug_log "DEBUG: execute_step - calling substitute_variables with url=$url"
    url=$(substitute_variables "$url")
    local t_after_subst=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: substitute_variables (URL) took $((t_after_subst - t_before_subst))ms" >&2
    debug_log "DEBUG: execute_step - after substitution url=$url"

    # Build curl command
    local curl_cmd="curl -s -w '\n%{http_code}' -X $method"

    # Add timeout if present (use both max-time and connect-timeout for reliability)
    if echo "$step_json" | jq -e '.timeout' > /dev/null 2>&1; then
        local timeout=$(echo "$step_json" | jq -r '.timeout')
        curl_cmd+=" --max-time $timeout --connect-timeout $timeout"
    fi

    # Add headers if present (OPTIMIZED: process ALL headers at once)
    local t_before_headers=$(date +%s%3N)
    local final_headers_json="{}"

    if echo "$step_json" | jq -e '.headers' > /dev/null 2>&1; then
        debug_log "DEBUG: Headers found in step_json"

        # Get headers as JSON string
        local headers_json=$(echo "$step_json" | jq -c '.headers')

        # Process ALL headers at once (massive performance improvement)
        # 1. Replace dynamic placeholders in entire JSON
        headers_json=$(replace_dynamic_placeholders "$headers_json")

        # 2. Substitute variables in entire JSON
        headers_json=$(substitute_variables "$headers_json")

        # Store final headers for logging
        final_headers_json="$headers_json"

        # 3. Extract headers and build curl command (single jq call)
        local headers_tsv=$(echo "$headers_json" | jq -r 'to_entries[] | [.key, .value] | @tsv')

        while IFS=$'\t' read -r key value; do
            if [ -n "$key" ]; then
                debug_log "DEBUG: Adding header: $key = $value"
                # Add header to curl command
                curl_cmd+=" -H '$key: $value'"
            fi
        done <<< "$headers_tsv"
    fi
    local t_after_headers=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: process headers took $((t_after_headers - t_before_headers))ms" >&2

    # Add body if present
    local t_before_body=$(date +%s%3N)
    local final_body=""
    if echo "$step_json" | jq -e '.body' > /dev/null 2>&1; then
        local body=$(echo "$step_json" | jq -c '.body')

        # Detect Content-Type for body processing
        local content_type="application/json"
        if echo "$step_json" | jq -e '.headers["Content-Type"]' > /dev/null 2>&1; then
            content_type=$(echo "$step_json" | jq -r '.headers["Content-Type"]')
        fi

        # Check for explicit bodyFormat
        local body_format="auto"
        if echo "$step_json" | jq -e '.bodyFormat' > /dev/null 2>&1; then
            body_format=$(echo "$step_json" | jq -r '.bodyFormat')
        fi

        body=$(process_body "$body" "$content_type" "$body_format")
        final_body="$body"
        curl_cmd+=" -d '$body'"
    fi
    local t_after_body=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: process body took $((t_after_body - t_before_body))ms" >&2

    # Add URL
    curl_cmd+=" '$url'"

    debug_log "DEBUG: Final curl command: $curl_cmd"

    # Execute curl and capture response
    local response_file="$TEMP_DIR/response_$step_index.txt"

    # Temporarily disable errexit to allow curl to fail gracefully and return exit code
    # Without this, set -e would cause the script to exit on curl errors
    set +e

    # Start timing the API call
    local start_time=$(date +%s%3N)
    eval "$curl_cmd" > "$response_file" 2>&1
    local curl_exit_code=$?
    local end_time=$(date +%s%3N)

    set -e

    # Calculate elapsed time in milliseconds
    local elapsed_ms=$((end_time - start_time))
    local elapsed_s=$(awk "BEGIN {printf \"%.3f\", $elapsed_ms/1000}")

    # Check for curl errors (including timeout)
    if [ $curl_exit_code -eq 28 ]; then
        echo -e "Step $step_num: $method $url ${RED}❌ Request timed out${NC}"
        if echo "$step_json" | jq -e '.timeout' > /dev/null 2>&1; then
            local timeout=$(echo "$step_json" | jq -r '.timeout')
            echo "Timeout limit: ${timeout}s"
        fi
        exit 1
    elif [ $curl_exit_code -ne 0 ]; then
        local error_desc=$(get_curl_error_description "$curl_exit_code")
        echo -e "Step $step_num: $method $url ${RED}❌ Curl failed with exit code $curl_exit_code ($error_desc)${NC}"
        # Show curl output in debug mode only (usually not helpful for connection errors)
        debug_log "Curl output: $(cat "$response_file")"
        exit 1
    fi

    # Extract status code (last line) and body (everything else)
    local status_code=$(tail -n 1 "$response_file")
    local response_body=$(head -n -1 "$response_file")

    # Store response JSON and status code for future reference
    responses_json+=("$response_body")
    responses_status+=("$status_code")

    # Build execution log entry (will be updated with validation results later)
    local t_before_log=$(date +%s%3N)

    # Array to track validation results for logging
    local validation_results_json="[]"

    # Helper function to add validation result
    add_validation_result() {
        local v_type="$1"
        local v_field="$2"
        local v_expected="$3"
        local v_actual="$4"
        local v_passed="$5"

        validation_results_json=$(echo "$validation_results_json" | jq \
            --arg type "$v_type" \
            --arg field "$v_field" \
            --arg expected "$v_expected" \
            --arg actual "$v_actual" \
            --arg passed "$v_passed" \
            '. + [{
                type: $type,
                field: $field,
                expected: $expected,
                actual: $actual,
                passed: ($passed == "true")
            }]')
    }

    # Helper function to update log entry with current validation results
    # Also sets failed step globals if validation failed (for metadata logging)
    update_log_entry_validations() {
        execution_log[$log_entry_index]=$(echo "${execution_log[$log_entry_index]}" | jq \
            --argjson validations "$validation_results_json" \
            '. + {validations: $validations}')

        # Check if any validation failed and set globals for metadata
        local has_failure=$(echo "$validation_results_json" | jq 'any(.[]; .passed == false)')
        if [ "$has_failure" = "true" ]; then
            FAILED_STEP_NUM="$step_num"
            FAILED_STEP_ID="$step_id"
        fi
    }

    local log_entry=$(jq -n \
        --arg step_num "$step_num" \
        --arg step_id "$step_id" \
        --arg name "$name" \
        --arg method "$method" \
        --arg url "$url" \
        --argjson headers "$final_headers_json" \
        --arg request_body "$final_body" \
        --arg status_code "$status_code" \
        --arg response_body "$response_body" \
        --arg elapsed_ms "$elapsed_ms" \
        '{
            step: ($step_num | tonumber),
            id: $step_id,
            name: $name,
            method: $method,
            url: $url,
            request: {
                headers: $headers,
                body: $request_body
            },
            response: {
                status: ($status_code | tonumber),
                body: $response_body
            },
            timing: {
                elapsed_ms: ($elapsed_ms | tonumber)
            }
        }')

    local t_after_log=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: build log entry took $((t_after_log - t_before_log))ms" >&2

    # Add log entry to execution log NOW (before validations)
    # This ensures the step is logged even if validation fails
    execution_log+=("$log_entry")
    local log_entry_index=$((${#execution_log[@]} - 1))

    # Process validations (unified status and jsonpath validations)
    local t_before_validations=$(date +%s%3N)
    if echo "$step_json" | jq -e '.validations' > /dev/null 2>&1; then
        # Check if validations array is explicitly empty (skip all validations)
        local validations_length=$(echo "$step_json" | jq '.validations | length')

        if [ "$validations_length" -eq 0 ]; then
            debug_log "DEBUG: Step has empty validations array - skipping all validations"
            # Empty array means skip all validations (including default status check)
            # Do nothing - will fall through to browser launch and success message
        else
            # Process non-empty validations array
            local validations=$(echo "$step_json" | jq -c '.validations[]')
            local validation_count=0
            local status_validated=false

        while IFS= read -r validation; do
            if [ -z "$validation" ]; then
                continue
            fi

            validation_count=$((validation_count + 1))

            # Extract ALL validation fields in ONE jq call (performance optimization)
            # Use null as placeholder for missing fields, then convert to string
            local validation_data=$(echo "$validation" | jq -r '[
                (.httpStatusCode // null),
                (.jsonpath // null),
                (.exists // null),
                (.equals // null),
                (.notEquals // null),
                (.greaterThan // null),
                (.lessThan // null),
                (.greaterThanOrEqual // null),
                (.lessThanOrEqual // null)
            ] | map(if . == null then "NULL_PLACEHOLDER" else . | tostring end) | @tsv')

            IFS=$'\t' read -r v_httpStatus v_jsonpath v_exists v_equals v_notEquals v_greaterThan v_lessThan v_greaterThanOrEqual v_lessThanOrEqual <<< "$validation_data"

            # Replace NULL_PLACEHOLDER with empty string
            [ "$v_httpStatus" = "NULL_PLACEHOLDER" ] && v_httpStatus=""
            [ "$v_jsonpath" = "NULL_PLACEHOLDER" ] && v_jsonpath=""
            [ "$v_exists" = "NULL_PLACEHOLDER" ] && v_exists=""
            [ "$v_equals" = "NULL_PLACEHOLDER" ] && v_equals=""
            [ "$v_notEquals" = "NULL_PLACEHOLDER" ] && v_notEquals=""
            [ "$v_greaterThan" = "NULL_PLACEHOLDER" ] && v_greaterThan=""
            [ "$v_lessThan" = "NULL_PLACEHOLDER" ] && v_lessThan=""
            [ "$v_greaterThanOrEqual" = "NULL_PLACEHOLDER" ] && v_greaterThanOrEqual=""
            [ "$v_lessThanOrEqual" = "NULL_PLACEHOLDER" ] && v_lessThanOrEqual=""

            # Substitute variables in comparison values
            [ -n "$v_equals" ] && v_equals=$(substitute_variables "$v_equals")
            [ -n "$v_notEquals" ] && v_notEquals=$(substitute_variables "$v_notEquals")
            [ -n "$v_greaterThan" ] && v_greaterThan=$(substitute_variables "$v_greaterThan")
            [ -n "$v_lessThan" ] && v_lessThan=$(substitute_variables "$v_lessThan")
            [ -n "$v_greaterThanOrEqual" ] && v_greaterThanOrEqual=$(substitute_variables "$v_greaterThanOrEqual")
            [ -n "$v_lessThanOrEqual" ] && v_lessThanOrEqual=$(substitute_variables "$v_lessThanOrEqual")

            # Check if this is a httpStatusCode validation
            if [ -n "$v_httpStatus" ]; then
                if [ "$status_code" != "$v_httpStatus" ]; then
                    add_validation_result "httpStatusCode" "status" "$v_httpStatus" "$status_code" "false"
                    update_log_entry_validations
                    echo -e "Step $step_num: $method $url ${RED}❌ Status $status_code (expected $v_httpStatus)${NC}"
                    echo "Response body: $response_body"
                    exit 1
                fi
                add_validation_result "httpStatusCode" "status" "$v_httpStatus" "$status_code" "true"
                status_validated=true

            # Check if this is a jsonpath validation
            elif [ -n "$v_jsonpath" ]; then
                local jsonpath="$v_jsonpath"

                if [ "$jsonpath" = "null" ] || [ -z "$jsonpath" ]; then
                    update_log_entry_validations
                    echo -e "Step $step_num: $method $url ${RED}❌ Validation $validation_count has invalid 'jsonpath' field${NC}"
                    exit 1
                fi

                local extracted=$(echo "$response_body" | jq -r "$jsonpath" 2>/dev/null || echo "null")

                # Check for 'exists' expectation
                if [ -n "$v_exists" ]; then
                    if [ "$v_exists" = "true" ]; then
                        if [ "$extracted" = "null" ] || [ -z "$extracted" ]; then
                            add_validation_result "jsonpath_exists" "$jsonpath" "true" "null" "false"
                            update_log_entry_validations
                            echo -e "Step $step_num: $method $url ${RED}❌ Expected field '$jsonpath' to exist${NC}"
                            echo "Response body: $response_body"
                            exit 1
                        else
                            add_validation_result "jsonpath_exists" "$jsonpath" "true" "$extracted" "true"
                            echo -e "  ${GREEN}✓${NC} Extracted $jsonpath = ${YELLOW}$extracted${NC}"
                        fi
                    else
                        if [ "$extracted" != "null" ] && [ -n "$extracted" ]; then
                            add_validation_result "jsonpath_exists" "$jsonpath" "false" "$extracted" "false"
                            update_log_entry_validations
                            echo -e "Step $step_num: $method $url ${RED}❌ Expected field '$jsonpath' to NOT exist${NC}"
                            exit 1
                        else
                            add_validation_result "jsonpath_exists" "$jsonpath" "false" "null" "true"
                            echo -e "  ${GREEN}✓${NC} Confirmed $jsonpath does not exist"
                        fi
                    fi
                fi

                # Check if equals is specified
                if [ -n "$v_equals" ]; then
                    if [ "$extracted" != "$v_equals" ]; then
                        add_validation_result "jsonpath_equals" "$jsonpath" "$v_equals" "$extracted" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ '$jsonpath' = '$extracted' (expected '$v_equals')${NC}"
                        exit 1
                    else
                        add_validation_result "jsonpath_equals" "$jsonpath" "$v_equals" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Validated $jsonpath = ${YELLOW}$extracted${NC}"
                    fi
                fi

                # Check if notEquals is specified
                if [ -n "$v_notEquals" ]; then
                    if [ "$extracted" = "$v_notEquals" ]; then
                        add_validation_result "jsonpath_notEquals" "$jsonpath" "NOT $v_notEquals" "$extracted" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ '$jsonpath' = '$extracted' (expected NOT '$v_notEquals')${NC}"
                        exit 1
                    else
                        add_validation_result "jsonpath_notEquals" "$jsonpath" "NOT $v_notEquals" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Validated $jsonpath = ${YELLOW}$extracted${NC} (not '$v_notEquals')"
                    fi
                fi

                # Check if greaterThan is specified
                if [ -n "$v_greaterThan" ]; then
                    # Use awk for floating point comparison
                    if ! awk -v val="$extracted" -v thresh="$v_greaterThan" 'BEGIN { exit !(val > thresh) }'; then
                        add_validation_result "jsonpath_greaterThan" "$jsonpath" "> $v_greaterThan" "$extracted" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ '$jsonpath' = '$extracted' (expected > $v_greaterThan)${NC}"
                        exit 1
                    else
                        add_validation_result "jsonpath_greaterThan" "$jsonpath" "> $v_greaterThan" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Validated $jsonpath = ${YELLOW}$extracted${NC} (> $v_greaterThan)"
                    fi
                fi

                # Check if lessThan is specified
                if [ -n "$v_lessThan" ]; then
                    # Use awk for floating point comparison
                    if ! awk -v val="$extracted" -v thresh="$v_lessThan" 'BEGIN { exit !(val < thresh) }'; then
                        add_validation_result "jsonpath_lessThan" "$jsonpath" "< $v_lessThan" "$extracted" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ '$jsonpath' = '$extracted' (expected < $v_lessThan)${NC}"
                        exit 1
                    else
                        add_validation_result "jsonpath_lessThan" "$jsonpath" "< $v_lessThan" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Validated $jsonpath = ${YELLOW}$extracted${NC} (< $v_lessThan)"
                    fi
                fi

                # Check if greaterThanOrEqual is specified
                if [ -n "$v_greaterThanOrEqual" ]; then
                    # Use awk for floating point comparison
                    if ! awk -v val="$extracted" -v thresh="$v_greaterThanOrEqual" 'BEGIN { exit !(val >= thresh) }'; then
                        add_validation_result "jsonpath_greaterThanOrEqual" "$jsonpath" ">= $v_greaterThanOrEqual" "$extracted" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ '$jsonpath' = '$extracted' (expected >= $v_greaterThanOrEqual)${NC}"
                        exit 1
                    else
                        add_validation_result "jsonpath_greaterThanOrEqual" "$jsonpath" ">= $v_greaterThanOrEqual" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Validated $jsonpath = ${YELLOW}$extracted${NC} (>= $v_greaterThanOrEqual)"
                    fi
                fi

                # Check if lessThanOrEqual is specified
                if [ -n "$v_lessThanOrEqual" ]; then
                    # Use awk for floating point comparison
                    if ! awk -v val="$extracted" -v thresh="$v_lessThanOrEqual" 'BEGIN { exit !(val <= thresh) }'; then
                        add_validation_result "jsonpath_lessThanOrEqual" "$jsonpath" "<= $v_lessThanOrEqual" "$extracted" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ '$jsonpath' = '$extracted' (expected <= $v_lessThanOrEqual)${NC}"
                        exit 1
                    else
                        add_validation_result "jsonpath_lessThanOrEqual" "$jsonpath" "<= $v_lessThanOrEqual" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Validated $jsonpath = ${YELLOW}$extracted${NC} (<= $v_lessThanOrEqual)"
                    fi
                fi

                # If no validation criteria specified, default to 'exists' check
                if [ -z "$v_exists" ] && [ -z "$v_equals" ] && [ -z "$v_notEquals" ] && \
                   [ -z "$v_greaterThan" ] && [ -z "$v_lessThan" ] && \
                   [ -z "$v_greaterThanOrEqual" ] && [ -z "$v_lessThanOrEqual" ]; then
                    if [ "$extracted" = "null" ] || [ -z "$extracted" ]; then
                        add_validation_result "jsonpath_default_exists" "$jsonpath" "exists" "null" "false"
                        update_log_entry_validations
                        echo -e "Step $step_num: $method $url ${RED}❌ JSON path '$jsonpath' not found${NC}"
                        echo "Response body: $response_body"
                        exit 1
                    else
                        add_validation_result "jsonpath_default_exists" "$jsonpath" "exists" "$extracted" "true"
                        echo -e "  ${GREEN}✓${NC} Extracted $jsonpath = ${YELLOW}$extracted${NC}"
                    fi
                fi
            else
                update_log_entry_validations
                echo -e "Step $step_num: $method $url ${RED}❌ Validation $validation_count must have either 'httpStatusCode' or 'jsonpath' field${NC}"
                exit 1
            fi
        done <<< "$validations"

        # If no status validation was found, default to 200
        if [ "$status_validated" = "false" ]; then
            if [ "$status_code" != "200" ]; then
                add_validation_result "httpStatusCode_default" "status" "200" "$status_code" "false"
                update_log_entry_validations
                echo -e "Step $step_num: $method $url ${RED}❌ Status $status_code (expected 200)${NC}"
                echo "Response body: $response_body"
                exit 1
            else
                add_validation_result "httpStatusCode_default" "status" "200" "$status_code" "true"
            fi
        fi
        fi  # Close the else block for non-empty validations
    else
        # No validations defined, default to checking status 200
        if [ "$status_code" != "200" ]; then
            add_validation_result "httpStatusCode_default" "status" "200" "$status_code" "false"
            update_log_entry_validations
            echo -e "Step $step_num: $method $url ${RED}❌ Status $status_code (expected 200)${NC}"
            echo "Response body: $response_body"
            exit 1
        else
            add_validation_result "httpStatusCode_default" "status" "200" "$status_code" "true"
        fi
    fi
    local t_after_validations=$(date +%s%3N)
    timing_log "[TIMING] Step $step_num: validations took $((t_after_validations - t_before_validations))ms" >&2

    # Update log entry with validation results (for successful validations)
    update_log_entry_validations

    # Check if step should launch browser
    if echo "$step_json" | jq -e '.launchBrowser' > /dev/null 2>&1; then
        local browser_jsonpath=$(echo "$step_json" | jq -r '.launchBrowser')
        local browser_url=$(echo "$response_body" | jq -r "$browser_jsonpath" 2>/dev/null || echo "null")

        if [ "$browser_url" != "null" ] && [ -n "$browser_url" ]; then
            launch_browser "$browser_url" "$step_num"
        else
            echo "Warning: Could not extract URL from response using jsonpath '$browser_jsonpath'" >&2
        fi
    fi

    # Print success with elapsed time
    echo -e "Step $step_num: $method $url ${GREEN}✅ Status $status_code OK${NC} (${elapsed_s}s)"

    local t_step_end=$(date +%s%3N)
    local step_overhead=$((t_step_end - t_step_start - elapsed_ms))
    timing_log "[TIMING] Step $step_num: TOTAL step time $((t_step_end - t_step_start))ms (API: ${elapsed_ms}ms, Overhead: ${step_overhead}ms)" >&2

    debug_log "DEBUG: execute_step returning for step $step_num"
}


# Main execution
main() {
    # Check for config file argument
    if [ $# -eq 0 ]; then
        usage
    fi

    CONFIG_FILE_PATH="$1"
    local config_file="$CONFIG_FILE_PATH"
    START_STEP="${2:-0}"  # Default to 0 if not provided (store globally for logging)
    local start_step="$START_STEP"

    # Validate start_step is a number
    if ! [[ "$start_step" =~ ^[0-9]+$ ]]; then
        echo "Error: start_step must be a non-negative integer"
        exit 1
    fi

    # Check if config file exists
    if [ ! -f "$config_file" ]; then
        echo "Error: Configuration file '$config_file' not found"
        exit 1
    fi

    # Check prerequisites
    check_prerequisites

    # Load configuration
    local config=$(cat "$config_file")

    # Validate JSON
    if ! echo "$config" | jq empty 2>/dev/null; then
        echo "Error: Invalid JSON in configuration file"
        exit 1
    fi

    # Validate step IDs
    validate_step_ids "$config"

    # Load defaults if present
    if echo "$config" | jq -e '.defaults' > /dev/null 2>&1; then
        DEFAULTS_JSON=$(echo "$config" | jq '.defaults')
        echo "Loaded defaults from configuration"
    fi

    # Load variables if present
    if echo "$config" | jq -e '.variables' > /dev/null 2>&1; then
        VARIABLES_JSON=$(echo "$config" | jq '.variables')
        local var_count=$(echo "$VARIABLES_JSON" | jq 'length')
        echo "Loaded $var_count global variable(s) from configuration"
    fi

    # Load enableDebug setting if present (defaults to false)
    if echo "$config" | jq -e '.enableDebug' > /dev/null 2>&1; then
        local enable_debug_value=$(echo "$config" | jq -r '.enableDebug')
        if [ "$enable_debug_value" = "true" ]; then
            ENABLE_DEBUG=true
            echo "Debug mode enabled"
        fi
    fi

    # Get number of steps
    local num_steps=$(echo "$config" | jq '.steps | length')

    if [ "$num_steps" -eq 0 ]; then
        echo "Error: No steps defined in configuration"
        exit 1
    fi

    # Validate start_step is within bounds
    if [ "$start_step" -ge "$num_steps" ]; then
        echo "Error: start_step ($start_step) must be less than number of steps ($num_steps)"
        exit 1
    fi

    if [ "$start_step" -eq 0 ]; then
        echo "Starting HTTP sequence with $num_steps steps..."
    else
        echo "Starting HTTP sequence from step $((start_step + 1)) (skipping first $start_step steps)..."
    fi
    echo ""

    # Track execution stats
    local steps_executed=0
    local steps_skipped=0

    # Populate empty responses for skipped initial steps (to maintain indexing)
    for ((i=0; i<start_step; i++)); do
        local step=$(echo "$config" | jq -c ".steps[$i]")
        local step_meta=$(echo "$step" | jq -r '[.name, .id, .method, .url] | @tsv')
        local step_num=$((i + 1))
        local name=$(echo "$step_meta" | cut -f1)
        local id=$(echo "$step_meta" | cut -f2)
        local method=$(echo "$step_meta" | cut -f3)
        local url=$(echo "$step_meta" | cut -f4)

        # Map step ID to index (even for skipped steps)
        response_ids["$id"]=$i

        # Store empty response and status for skipped steps
        responses_json+=("{}")
        responses_status+=("0")
        steps_skipped=$((steps_skipped + 1))

        echo -e "Step $step_num: $method $url ${YELLOW}⊘ SKIPPED${NC} (starting from step $((start_step + 1)))"
        debug_log "DEBUG: Skipped initial step $step_num (id=$id)"
    done

    if [ "$start_step" -gt 0 ]; then
        echo ""
    fi

    # Execute each step (starting from start_step)
    for ((i=start_step; i<num_steps; i++)); do
        debug_log "DEBUG: Loop iteration $i of $num_steps"
        local step_num=$((i + 1))
        # Extract step object once (optimization: 2 calls instead of 5)
        local step=$(echo "$config" | jq -c ".steps[$i]")
        # Extract metadata in single jq call
        local step_meta=$(echo "$step" | jq -r '[.name, .id, .method, .url] | @tsv')
        local name=$(echo "$step_meta" | cut -f1)
        local id=$(echo "$step_meta" | cut -f2)
        local method=$(echo "$step_meta" | cut -f3)
        local url=$(echo "$step_meta" | cut -f4)
        debug_log "DEBUG: Processing step $step_num: $name (id=$id)"

        # Map step ID to index for named references
        response_ids["$id"]=$i
        debug_log "DEBUG: Mapped response_ids[$id]=$i"

        # Check if step has a condition
        if echo "$step" | jq -e '.condition' > /dev/null 2>&1; then
            local condition=$(echo "$step" | jq '.condition')

            # Evaluate the condition
            if evaluate_condition "$condition" "$step_num"; then
                # Condition passed, execute step
                execute_step "$i" "$step"
                steps_executed=$((steps_executed + 1))
            else
                # Condition failed, skip step
                echo -e "Step $step_num: $method $url ${BLUE}⊘ SKIPPED${NC} (condition not met)"
                steps_skipped=$((steps_skipped + 1))

                # Store empty response and status for skipped steps to maintain indexing
                responses_json+=("{}")
                responses_status+=("0")
            fi
        else
            # No condition, execute step normally
            debug_log "DEBUG: About to execute step $step_num (no condition)"
            execute_step "$i" "$step"
            debug_log "DEBUG: Completed executing step $step_num"
            steps_executed=$((steps_executed + 1))
        fi
        debug_log "DEBUG: End of loop iteration $i"
    done
    debug_log "DEBUG: Exited loop"

    echo ""
    echo -e "${GREEN}Sequence completed: $steps_executed executed, $steps_skipped skipped 🎉${NC}"

    # Mark sequence as completed successfully (for EXIT trap to determine status)
    SEQUENCE_COMPLETED=true
}

# Run main function (EXIT trap will handle log prompt)
main "$@"
